# Natural Language OS Control Prototype

## Overview

This project is a prototype that enables users to control an operating system using natural language commands. The system interprets a user’s query, such as “shut down the PC,” and executes it by generating and running the necessary code via multiple large language models (LLMs). This README provides an overview of the workflow and design strategy of the project, which utilizes .NET and C# for execution.

## Workflow

The project workflow consists of several stages, involving three separate LLMs to ensure robust task handling, even when errors occur. The following outlines the process:

1. **User Query Input**: 
   - The user enters a natural language query, specifying the desired system action (e.g., “Shut down the PC”).

2. **LLM 1: Action Strategy Generation**:
   - The query is sent to **LLM 1**, a model tasked with analyzing the user’s request.
   - **System Prompt**: LLM 1 is given a prompt to act as an OS control assistant, responsible for determining the appropriate approach for the requested action. It evaluates available packages, resources, and system information to plan the action.
   - **Output**: LLM 1 produces a high-level strategy, including guidance on the packages and methods needed to perform the action in .NET/C#.

3. **LLM 2: Code Generation**:
   - **LLM 2** receives the strategy generated by LLM 1 and translates it into executable C# code.
   - The code is then executed in the terminal to perform the action on the operating system.

4. **Error Handling (If Needed)**:
   - If an error occurs during code execution, it is fed into **LLM 3**.
   - **LLM 3** analyzes the error and generates a new strategy, taking the error into account to optimize the solution.
   - The revised strategy is then sent back to **LLM 2**, which generates new code based on the feedback.
   - This loop continues until the action completes successfully.

## Features

- **Natural Language Interface**: Enables users to perform complex OS actions through simple natural language commands.
- **Multi-LLM Coordination**: Uses a multi-step LLM process to plan, code, and handle errors dynamically.
- **Error Resilience**: In case of execution errors, LLM 3 provides alternative strategies to retry the process.

## Getting Started

### Prerequisites

- .NET framework
- Compatible LLM APIs for each LLM stage
- A terminal that supports C# code execution

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/your-username/your-project.git
   ```
2. Install necessary dependencies:
   ```bash
   cd your-project
   # Add commands to install necessary .NET packages or LLM libraries
   ```

### Usage

1. Start the application:
   ```bash
   dotnet run
   ```
2. Enter a natural language command when prompted, such as "Shut down the PC".
3. Follow the on-screen instructions to monitor progress, view generated code, or handle any errors.

### Example Command Flow

1. **User Input**: “Restart the computer.”
2. **LLM 1**: Determines the packages and strategy to restart the system.
3. **LLM 2**: Generates C# code based on LLM 1’s strategy.
4. **Execution**: Code is executed. If it fails:
   - **LLM 3**: Analyzes the error, creates an adjusted strategy, and sends it to LLM 2 for new code generation.
5. **Repeat**: Steps 3–4 until success.

## Contributing

We welcome contributions! Please follow these steps:

1. Fork the repository.
2. Create a feature branch (`git checkout -b feature/your-feature`).
3. Commit your changes (`git commit -m 'Add your feature'`).
4. Push to the branch (`git push origin feature/your-feature`).
5. Open a pull request.
